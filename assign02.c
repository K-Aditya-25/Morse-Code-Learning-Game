#include <stdio.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "hardware/regs/timer.h"
#include "assign02.pio.h"
#include "hardware/watchdog.h"
#include <time.h>
#include "morse_code.h"
#include "welcome.h"
#include <math.h>

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to


//srand(time(NULL));
//Global Variables
absolute_time_t start_time;
absolute_time_t null_time; 
int lives = 3;
int level = 0;
int attempts = 0;
int count;
int flag=0;

//Parameters to deal with lives
int success;
int success_count;
int failed;
int failed_count;
int correct;


char levelChoice[5];
char answer[50];
int i=0;
int j=0;
char morse[50];

// Must declare the main assembly entry point before use.
void main_asm();

// Initialise a GPIO pin – see SDK for detail on gpio_init()
void asm_gpio_init(uint pin) {
    gpio_init(pin);
}

// Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
void asm_gpio_set_dir(uint pin, bool out) {
    gpio_set_dir(pin, out);
}

// Get the value of a GPIO pin – see SDK for detail on gpio_get()
bool asm_gpio_get(uint pin) {
    return gpio_get(pin);
}

// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
    gpio_put(pin, value);
}




// Enable falling-edge & rising-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irq(uint pin) {
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);
}

void level1(){
    int index = rand()%36;
    char letter = alpha_table[index];
    strcpy(morse, morse_encode(letter));
    printf("\nYour Target Character is: %c, Corresponding Morse Code is: %s\n",letter,morse);
}
void level2(){
    int index = rand()%36;
    char letter = alpha_table[index];
    printf("Your Target Character is: %c\n",letter);
}

void levels_call(int level){
    if (level >= 3){
        printf("Congrats, Game Completed!\n\n");
    }
    else{
        if (level == 1){
        level1();
        //RGB_LED(2);
        }
        else if (level == 2)
        {
            level2();
            //RGB_LED(2);
        }
    }
    
}

void start_timestamp()
{
   start_time = get_absolute_time();
}

int pressed_time()
{
    int64_t no_space = absolute_time_diff_us(start_time, null_time);
    int check = (int) no_space;
    if(check == 0){
        return 0;
    }
    int64_t difference = absolute_time_diff_us(start_time, get_absolute_time());
    return (int) difference;
}

void check(char answer[]){
    if (strcmp(morse,answer)==0){
        printf("Correct Answer");
        correct++;
        //lives=min(lives+1,3);
        printf("Your stats are ");
        if(correct%5==0){
            level++;
        }
        clearArray(answer);
        levels_call(level);
    }
    else{
        //lives=max(lives-1,0);
        correct=0;
        printf("Your stats are ");
        if(lives==0){
            printf("\nGame over");
        }
    }
}

void clearArray(char Answer)
{
    i = 0;
    for (int k = 0; k < 50; k++)
    {
         answer[k] = '\0';
    }
}



void addtoanswer(int num){

    if (flag==0){//choosing a level right now
        if (num == 1){
            answer[i] = '.';
            i++;
        }
        else if (num == 2){
            answer[i] = '-';
            i++;
        }
        else if (num == 3){
            answer[i] = ' ';
            i++;
        }
        else{
            answer[i]='\0';
            level = morse_decode(answer)-'0';
            flag=1;
            if(level == 1)
            {
                clearArray(answer);
                level1();
            }
        }
    }
    else{
          if (num == 1){
            answer[i] = '.';
            i++;
        }
        else if (num == 2){
            answer[i] = '-';
            i++;
        }
        else if (num == 3){
            answer[i] = ' ';
            i++;
        }
        else{
            answer[i]='\0';
            count++;
            check(answer);
        }  
    }

}


/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}

/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

/**
 * @brief Function to set LED to dif colours depending on scenario
 * 
 * @param b     There is no game in progress
 * @param g     A level has been chosen, the game begins
 * @param r     GAME OVER
 *
*/
void RGB_LED(int temp1)//input to be decided)
{
    int temp = 0;
    if (temp == 1)//no ongoing game)
    {
        put_pixel(urgb_u32(0x00, 0x00, 0x7F));
    }
    if (temp == 2)//level chosen)
    {
        put_pixel(urgb_u32(0x00, 0x7F, 0x00));
    }
    if (temp == 3)//GAME OVER)
    {
        put_pixel(urgb_u32(0x7F, 0x00, 0x00));
    }
    if (temp == 4)//2 lives) yellow
    {
        put_pixel(urgb_u32(0xA1, 0xA1, 0x00));
    }
    if (temp == 5)//1 life) orange
    {
        put_pixel(urgb_u32(0xA1, 0x32, 0x00));
    }
}

void gameOver(){
    printf(" ██████╗  █████╗ ███╗   ███╗███████╗\n");
    printf("██╔════╝ ██╔══██╗████╗ ████║██╔════╝\n");
    printf("██║  ███╗███████║██╔████╔██║█████╗  \n");
    printf("██║   ██║██╔══██║██║╚██╔╝██║██╔══╝  \n");
    printf("╚██████╔╝██║  ██║██║ ╚═╝ ██║███████╗\n");
    printf(" ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝\n\n");
    printf(" ██████╗ ██╗   ██╗███████╗██████╗   \n");
    printf("██╔═══██╗██║   ██║██╔════╝██╔══██╗  \n");
    printf("██║   ██║██║   ██║█████╗  ██████╔╝  \n");
    printf("██║   ██║╚██╗ ██╔╝██╔══╝  ██╔══██╗  \n");
    printf("╚██████╔╝ ╚████╔╝ ███████╗██║  ██║  \n");
    printf(" ╚═════╝   ╚═══╝  ╚══════╝╚═╝  ╚═╝  \n");
}


/*
 * Main entry point for the code - simply calls the main assembly function.
 */
int main() {
    stdio_init_all();         // Initialise all basic IO
    sleep_ms(5000);
    RGB_LED(1);
    welcome();                // Calling the welcome function
    
    //watchdog_enable(9*1000000); //timeout of approx 9 seconds

    while (true){
        //handle input 
        //input detection 
        watchdog_update(); //timer reset if input detected
        main_asm();
    }

    return(0);
}